/**
 * Copyright 2014 Tampere University of Technology, Pori Unit
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package service.tut.pori.users.twitter;

import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;

import service.tut.pori.users.UserDAO;
import twitter4j.auth.AccessToken;
import core.tut.pori.dao.clause.SQLClause.SQLType;
import core.tut.pori.dao.SQLDAO;
import core.tut.pori.users.ExternalAccountConnection;
import core.tut.pori.users.UserIdentity;
import core.tut.pori.users.ExternalAccountConnection.UserServiceType;

/**
 * DAO for handling authorization tokens for Twitter User Service.
 */
public class TwitterUserDAO extends SQLDAO {
	private static final Logger LOGGER = Logger.getLogger(TwitterUserDAO.class);
	/* tables */
	private static final String TABLE_USERS_TWITTER = DATABASE+".users_twitter";
	private static final String TABLE_USERS_TWITTER_REQUEST_TOKENS = DATABASE+".users_twitter_request_tokens";
	/* columns */
	private static final String COLUMN_ACCESS_TOKEN = "access_token";
	private static final String COLUMN_ACCESS_TOKEN_SECRET = "access_token_secret";
	private static final String COLUMN_REDIRECT_URI = "redirect_uri";
	private static final String COLUMN_REQUEST_TOKEN = "request_token";
	private static final String COLUMN_REQUEST_TOKEN_SECRET = "request_token_secret";
	/* sql scripts */
	private static final String SQL_GET_ACCESS_TOKEN = "SELECT "+COLUMN_ACCESS_TOKEN+", "+COLUMN_ACCESS_TOKEN_SECRET+" FROM "+TABLE_USERS_TWITTER+" WHERE "+COLUMN_USER_ID+"=?";
	
	private static final String SQL_INSERT_REQUEST_TOKEN = "INSERT INTO "+TABLE_USERS_TWITTER_REQUEST_TOKENS+" ("+COLUMN_USER_ID+", "+COLUMN_REQUEST_TOKEN+", "+COLUMN_REQUEST_TOKEN_SECRET+", "+COLUMN_REDIRECT_URI+", "+COLUMN_ROW_CREATED+") VALUES (?,?,?,?,NOW())";
	private static final int[] SQL_INSERT_REQUEST_TOKEN_SQL_TYPES = {SQLType.LONG.toInt(), SQLType.STRING.toInt(), SQLType.STRING.toInt(), SQLType.STRING.toInt()};
	
	private static final String SQL_GET_REQUEST_TOKEN = "SELECT "+COLUMN_USER_ID+", "+COLUMN_REQUEST_TOKEN_SECRET+", "+COLUMN_REDIRECT_URI+", "+COLUMN_ROW_UPDATED+" FROM "+TABLE_USERS_TWITTER_REQUEST_TOKENS+" WHERE "+COLUMN_REQUEST_TOKEN+"=?";
		
	private static final String SQL_REMOVE_ACCESS_TOKEN_BY_USER = "DELETE FROM "+TABLE_USERS_TWITTER+" WHERE "+COLUMN_USER_ID+"=?";
	
	private static final String SQL_REMOVE_REQUEST_TOKEN = "DELETE FROM "+TABLE_USERS_TWITTER_REQUEST_TOKENS+" WHERE "+COLUMN_REQUEST_TOKEN+"=?";
	
	private static final String SQL_REMOVE_REQUEST_TOKEN_BY_USER = "DELETE FROM "+TABLE_USERS_TWITTER_REQUEST_TOKENS+" WHERE "+COLUMN_USER_ID+"=?";
	
	private static final int[] SQL_REQUEST_TOKEN_SQL_TYPE = {SQLType.STRING.toInt()};
	
	/** tokens generated by twitter should be unique, so the unique column constraint on access token should never match on ON DUPLICATE KEY UPDATE for two different users, the match will be solely done on user id */
	private static final String SQL_SET_ACCESS_TOKEN = "INSERT INTO "+TABLE_USERS_TWITTER+" ("+COLUMN_USER_ID+","+COLUMN_ACCESS_TOKEN+","+COLUMN_ACCESS_TOKEN_SECRET+","+COLUMN_ROW_CREATED+") VALUES (?,?,?,NOW()) ON DUPLICATE KEY UPDATE "+COLUMN_ACCESS_TOKEN+"=VALUES("+COLUMN_ACCESS_TOKEN+"), "+COLUMN_ACCESS_TOKEN_SECRET+"=VALUES("+COLUMN_ACCESS_TOKEN_SECRET+")";
	private static final int[] SQL_SET_ACCESS_TOKEN_SQL_TYPES = {SQLType.LONG.toInt(),SQLType.STRING.toInt(),SQLType.STRING.toInt()};
	
	private static final String SQL_SET_REQUEST_TOKEN = "INSERT INTO "+TABLE_USERS_TWITTER_REQUEST_TOKENS+" ("+COLUMN_USER_ID+", "+COLUMN_REQUEST_TOKEN+", "+COLUMN_REQUEST_TOKEN_SECRET+", "+COLUMN_REDIRECT_URI+", "+COLUMN_ROW_CREATED+") VALUES (?,?,?,?,NOW()) ON DUPLICATE KEY UPDATE "+COLUMN_REQUEST_TOKEN+"=VALUES("+COLUMN_REQUEST_TOKEN+"), "+COLUMN_REQUEST_TOKEN_SECRET+"=VALUES("+COLUMN_REQUEST_TOKEN_SECRET+"), "+COLUMN_REDIRECT_URI+"=VALUES("+COLUMN_REDIRECT_URI+")";
	private static final int[] SQL_SET_REQUEST_TOKEN_SQL_TYPES = {SQLType.LONG.toInt(), SQLType.STRING.toInt(), SQLType.STRING.toInt(), SQLType.STRING.toInt()};
	
	private static final int[] SQL_USER_IDENTITY_SQL_TYPE = {SQLType.LONG.toInt()};
	
	@Autowired
	private UserDAO _userDAO = null;
	
	/**
	 * 
	 * @param token
	 */
	public void setRequestToken(RequestToken token) {
		Long userId = token.getUserIdValue();
		if(userId == null){ // do not use on duplicate update for null, so that a new row will always be added
			getJdbcTemplate().update(SQL_INSERT_REQUEST_TOKEN, new Object[]{userId, token.getToken(), token.getSecret(), token.getRedirectUri()}, SQL_INSERT_REQUEST_TOKEN_SQL_TYPES);
		}else{
			getJdbcTemplate().update(SQL_SET_REQUEST_TOKEN, new Object[]{userId, token.getToken(), token.getSecret(), token.getRedirectUri()}, SQL_SET_REQUEST_TOKEN_SQL_TYPES);
		}
	}

	/**
	 * This will remove both the access token and the request token associated with the given user (if any)
	 * 
	 * @param userIdentity valid user identity
	 */
	public void removeTokens(UserIdentity userIdentity) {
		Object[] ob = {userIdentity.getUserId()};
		JdbcTemplate t = getJdbcTemplate();
		if(t.update(SQL_REMOVE_ACCESS_TOKEN_BY_USER, ob, SQL_USER_IDENTITY_SQL_TYPE) < 1){
			LOGGER.debug("No access tokens removed for user, id: "+ob[0]);
		}
		if(t.update(SQL_REMOVE_REQUEST_TOKEN_BY_USER, ob, SQL_USER_IDENTITY_SQL_TYPE) < 1){
			LOGGER.debug("No request tokens removed for user, id: "+ob[0]);
		}
	}

	/**
	 * 
	 * @param token the request token value
	 * @return the fully populated request token or null if not found
	 */
	public RequestToken getRequestToken(String token) {
		List<Map<String, Object>> rows = getJdbcTemplate().queryForList(SQL_GET_REQUEST_TOKEN, new Object[]{token}, SQL_REQUEST_TOKEN_SQL_TYPE);
		if(rows.isEmpty()){
			LOGGER.debug("The request token was not found.");
			return null;
		}
		RequestToken requestToken = extractRequestToken(rows.get(0));
		requestToken.setToken(token);
		return requestToken;
	}
	
	/**
	 * 
	 * @param row
	 * @return the token or null on failure
	 */
	private RequestToken extractRequestToken(Map<String, Object> row){
		RequestToken token = new RequestToken();
		for(Entry<String, Object> e : row.entrySet()){
			String column = e.getKey();
			switch(column){
				case COLUMN_USER_ID:
					token.setUserId(new UserIdentity((Long) e.getValue()));
					break;
				case COLUMN_REQUEST_TOKEN:
					token.setToken((String) e.getValue());
					break;
				case COLUMN_REQUEST_TOKEN_SECRET:
					token.setSecret((String) e.getValue());
					break;
				case COLUMN_REDIRECT_URI:
					token.setRedirectUri((String) e.getValue());
					break;
				case COLUMN_ROW_UPDATED:
					token.setUpdated((Date) e.getValue());
					break;
				default:
					LOGGER.warn("Ignored unknown column: "+column);
					break;
			}
		}
		return token;
	}

	/**
	 * 
	 * @param token
	 */
	public void removeRequestToken(RequestToken token) {
		removeRequestToken(token.getToken());
	}
	
	/**
	 * 
	 * @param requestToken
	 */
	private void removeRequestToken(String requestToken) {
		if(getJdbcTemplate().update(SQL_REMOVE_REQUEST_TOKEN, new Object[]{requestToken}, SQL_REQUEST_TOKEN_SQL_TYPE) < 1){
			LOGGER.debug("No token removed, request token: "+requestToken);
		}
	}

	/**
	 * 
	 * @param authorizedUser a valid user
	 * @return access token for the given user or null if none was found
	 */
	public AccessToken getAccessToken(UserIdentity authorizedUser) {
		List<Map<String, Object>> rows = getJdbcTemplate().queryForList(SQL_GET_ACCESS_TOKEN, new Object[]{authorizedUser.getUserId()}, SQL_USER_IDENTITY_SQL_TYPE);
		if(rows.isEmpty()){
			LOGGER.debug("No access token found for user, id: "+authorizedUser.getUserId());
			return null;
		}
		
		Map<String, Object> row = rows.get(0);
		return new AccessToken((String)row.get(COLUMN_ACCESS_TOKEN), (String) row.get(COLUMN_ACCESS_TOKEN_SECRET));
	}

	/**
	 * 
	 * @param twitterUserId
	 * @param token
	 * @param userId
	 * @return true on success
	 */
	public boolean setAccessToken(final String twitterUserId, final AccessToken token, final UserIdentity userId) {
		if(!UserIdentity.isValid(userId) || token == null || StringUtils.isBlank(twitterUserId)){
			LOGGER.debug("Invalid userId or token.");
			return false;
		}
		
		return getTransactionTemplate().execute(new TransactionCallback<Boolean>() {

			@Override
			public Boolean doInTransaction(TransactionStatus status) {			
				JdbcTemplate t = getJdbcTemplate();
				
				String oldTwitterUserId = getTwitterUserId(userId);
				if(oldTwitterUserId == null){
					LOGGER.debug("Creating a new external account connection for user, id: "+userId.getUserId()+", google user id: "+twitterUserId);
					_userDAO.insertExternalAccountConnection(new ExternalAccountConnection(twitterUserId, UserServiceType.TWITTER), userId);
				}else if(!oldTwitterUserId.equals(twitterUserId)){ // do not allow changing the twitter user, this may cause undefined behavior on other parts of the system
					LOGGER.warn("The given twitter user Id "+twitterUserId+" did not match the old twitter user id: "+oldTwitterUserId);
					return false;
				}
				
				t.update(SQL_SET_ACCESS_TOKEN, new Object[]{userId.getUserId(),token.getToken(),token.getTokenSecret()}, SQL_SET_ACCESS_TOKEN_SQL_TYPES);
				
				return true;
			}
		});
	}
	
	/**
	 * 
	 * @param userId non-null, valid userId
	 * @return twitter user id for the given userId, if known by the system, otherwise returns null
	 */
	public String getTwitterUserId(UserIdentity userId){
		ExternalAccountConnection connection = _userDAO.getExternalAccountConnection(userId, UserServiceType.TWITTER);
		return (connection == null ? null : connection.getExternalId());
	}
}
