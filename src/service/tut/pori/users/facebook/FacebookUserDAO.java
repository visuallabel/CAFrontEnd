/**
 * Copyright 2014 Tampere University of Technology, Pori Department
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package service.tut.pori.users.facebook;

import java.util.Date;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;

import service.tut.pori.users.google.OAuth2Token;
import service.tut.pori.users.UserDAO;
import core.tut.pori.dao.SQLDAO;
import core.tut.pori.dao.clause.SQLClause.SQLType;
import core.tut.pori.users.ExternalAccountConnection;
import core.tut.pori.users.UserIdentity;
import core.tut.pori.users.ExternalAccountConnection.UserServiceType;
import core.tut.pori.utils.NonceUtils;
import core.tut.pori.utils.NonceUtils.Nonce;

/**
 * DAO for handling authorization tokens for Facebook User Service.
 *
 */
public class FacebookUserDAO extends SQLDAO {
	private static final Logger LOGGER = Logger.getLogger(FacebookUserDAO.class);
	/* tables */
	private static final String TABLE_USERS_FACEBOOK = DATABASE+".users_facebook";
	/* columns */
	private static final String COLUMN_ACCESS_TOKEN = "access_token";
	private static final String COLUMN_ACCESS_TOKEN_EXPIRES = "access_token_expires";
	private static final String COLUMN_NONCE = "nonce";
	private static final String COLUMN_NONCE_EXPIRES = "nonce_expires";
	/* sql strings */	
	private static final String SQL_COUNT_USER_ID = "SELECT "+COLUMN_COUNT+" FROM "+TABLE_USERS_FACEBOOK+" WHERE "+COLUMN_USER_ID+"=?";
	private static final int[] SQL_COUNT_USER_ID_SQL_TYPES = new int[]{SQLType.LONG.toInt()};

	private static final String SQL_INSERT_NONCE = "INSERT INTO "+TABLE_USERS_FACEBOOK+" ("+COLUMN_USER_ID+","+COLUMN_NONCE+","+COLUMN_NONCE_EXPIRES+","+COLUMN_ROW_CREATED+") VALUES (?,?,?,NOW())";
	private static final int[] SQL_INSERT_NONCE_SQL_TYPES = new int[]{SQLType.LONG.toInt(),SQLType.STRING.toInt(),SQLType.LONG.toInt()};

	private static final String SQL_REMOVE_NONCE = "UPDATE "+TABLE_USERS_FACEBOOK+" SET "+COLUMN_NONCE+"=NULL WHERE "+COLUMN_NONCE+"=? LIMIT 1";
	private static final int[] SQL_REMOVE_NONCE_SQL_TYPES = new int[]{SQLType.STRING.toInt()};
	
	private static final String SQL_REMOVE_TOKEN = "DELETE FROM "+TABLE_USERS_FACEBOOK+" WHERE "+COLUMN_USER_ID+"=?";
	private static final int[] SQL_REMOVE_TOKEN_SQL_TYPES = new int[]{SQLType.LONG.toInt()};
	
	private static final String SQL_SELECT_TOKEN = "SELECT "+COLUMN_COUNT+", "+COLUMN_ACCESS_TOKEN+", "+COLUMN_ACCESS_TOKEN_EXPIRES+" FROM "+TABLE_USERS_FACEBOOK+" WHERE "+COLUMN_USER_ID+"=? AND "+COLUMN_ACCESS_TOKEN_EXPIRES+">? LIMIT 1";
	private static final int[] SQL_SELECT_TOKEN_SQL_TYPES = new int[]{SQLType.LONG.toInt(),SQLType.LONG.toInt()};
	
	private static final String SQL_SELECT_USER_ID = "SELECT "+COLUMN_COUNT+", "+COLUMN_USER_ID+" FROM "+TABLE_USERS_FACEBOOK+" WHERE "+COLUMN_NONCE+"=? AND "+COLUMN_NONCE_EXPIRES+">? LIMIT 1";
	private static final int[] SQL_SELECT_USER_ID_SQL_TYPES = new int[]{SQLType.STRING.toInt(),SQLType.LONG.toInt()};

	/** tokens generated by facebook should be unique, so the unique column constraint on access token should never match on ON DUPLICATE KEY UPDATE for two different users, the match will be solely done on user id */
	private static final String SQL_SET_TOKEN = "INSERT INTO "+TABLE_USERS_FACEBOOK+" ("+COLUMN_USER_ID+","+COLUMN_ACCESS_TOKEN+","+COLUMN_ACCESS_TOKEN_EXPIRES+","+COLUMN_ROW_CREATED+") VALUES (?,?,?,NOW()) ON DUPLICATE KEY UPDATE "+COLUMN_ACCESS_TOKEN+"=VALUES("+COLUMN_ACCESS_TOKEN+"), "+COLUMN_ACCESS_TOKEN_EXPIRES+"=VALUES("+COLUMN_ACCESS_TOKEN_EXPIRES+")";
	private static final int[] SQL_SET_TOKEN_SQL_TYPES = new int[]{SQLType.LONG.toInt(),SQLType.STRING.toInt(),SQLType.LONG.toInt()};
	
	private static final String SQL_UPDATE_NONCE = "UPDATE "+TABLE_USERS_FACEBOOK+" SET "+COLUMN_NONCE+"=?,"+COLUMN_NONCE_EXPIRES+"=? WHERE "+COLUMN_USER_ID+"=?";
	private static final int[] SQL_UPDATE_NONCE_SQL_TYPES = new int[]{SQLType.STRING.toInt(),SQLType.LONG.toInt(),SQLType.LONG.toInt()};
	
	@Autowired
	private UserDAO _userDAO = null;
	
	/**
	 * 
	 * @param facebookUserId
	 * @param token
	 * @param userId
	 * @return true on success
	 */
	public boolean setToken(final String facebookUserId, final OAuth2Token token, final UserIdentity userId){
		if(!UserIdentity.isValid(userId) || !token.isValid() || StringUtils.isBlank(facebookUserId)){
			LOGGER.debug("Invalid userId or token.");
			return false;
		}
		
		return getTransactionTemplate().execute(new TransactionCallback<Boolean>() {

			@Override
			public Boolean doInTransaction(TransactionStatus status) {			
				JdbcTemplate t = getJdbcTemplate();
				
				String oldFacebookUserId = getFacebookUserId(userId);
				if(oldFacebookUserId == null){
					LOGGER.debug("Creating a new external account connection for user, id: "+userId.getUserId()+", google user id: "+facebookUserId);
					_userDAO.insertExternalAccountConnection(new ExternalAccountConnection(facebookUserId, UserServiceType.FACEBOOK), userId);
				}else if(!oldFacebookUserId.equals(facebookUserId)){ // do not allow changing the facebook user, this may cause undefined behavior on other parts of the system
					LOGGER.warn("The given facebook user Id "+facebookUserId+" did not match the old facebook user id: "+oldFacebookUserId);
					return false;
				}
				
				t.update(SQL_SET_TOKEN, new Object[]{userId.getUserId(),token.getAccessToken(),token.getExpires().getTime()}, SQL_SET_TOKEN_SQL_TYPES);
				
				return true;
			}
		});
	}
	
	/**
	 * 
	 * @param userId non-null, valid userid
	 * @return facebook user id for the given userId, if known by the system, otherwise returns null
	 */
	public String getFacebookUserId(UserIdentity userId){
		ExternalAccountConnection connection = _userDAO.getExternalAccountConnection(userId, UserServiceType.FACEBOOK);
		return (connection == null ? null : connection.getExternalId());
	}
	
	/**
	 * 
	 * @param nonce
	 */
	public void removeNonce(String nonce){
		if(getJdbcTemplate().update(SQL_REMOVE_NONCE, new Object[]{nonce}, SQL_REMOVE_NONCE_SQL_TYPES) < 1){
			LOGGER.debug("No nonce was cleared.");
		}else{
			LOGGER.debug("Nonce cleared.");
		}
	}
	
	/**
	 * 
	 * @param userId
	 * @return token for the given user or null if none available
	 */
	public OAuth2Token getToken(UserIdentity userId){
		if(!UserIdentity.isValid(userId)){
			LOGGER.debug("Invalid userId.");
			return null;
		}
		
		OAuth2Token token = new OAuth2Token();
		Map<String, Object> row = getJdbcTemplate().queryForMap(SQL_SELECT_TOKEN, new Object[]{userId.getUserId(), System.currentTimeMillis()}, SQL_SELECT_TOKEN_SQL_TYPES);
		for(Entry<String,Object> entry : row.entrySet()){
			switch(entry.getKey()){
				case COLUMN_ACCESS_TOKEN:
					token.setAccessToken((String) entry.getValue());
					break;
				case COLUMN_ACCESS_TOKEN_EXPIRES:
					token.setExpires(new Date((Long) entry.getValue()));
					break;
				default:
					if(checkCountColumn(entry.getKey(), entry.getValue()) < 1){	// if we have only one column, check what it is (should be count)
						LOGGER.debug("Unknown column name, or no results.");
						return null;
					}
					break;
			}
		}
		return token;
	}
	
	/**
	 * This generates a new nonce from the given UserId, replacing the old one if one was present
	 * 
	 * @param userId
	 * @return randomly generated nonce for the given user
	 */
	public String generateNonce(UserIdentity userId){
		if(!UserIdentity.isValid(userId)){
			LOGGER.debug("Invalid userId.");
			return null;
		}
		Nonce nonce = NonceUtils.generateNonce();	// in theory, it is extremely unlikely that the generated nonce will collide with previously generated one, but...
		if(recordExists(userId.getUserId())){ // ...just in case do not use INSERT ... ON DUPLICATE KEY UPDATE for updating the nonce (as nonce itself is an unique column)
			getJdbcTemplate().update(SQL_UPDATE_NONCE, new Object[]{nonce.getNonce(),nonce.getExpires(),userId.getUserId()}, SQL_UPDATE_NONCE_SQL_TYPES);	// this throw an exception on duplicate nonce if one ever occurs
		}else{
			getJdbcTemplate().update(SQL_INSERT_NONCE, new Object[]{userId.getUserId(),nonce.getNonce(),nonce.getExpires()}, SQL_INSERT_NONCE_SQL_TYPES);	// this throw an exception on duplicate nonce if one ever occurs
		}
		return nonce.getNonce();
	}
	
	/**
	 * remove token from the given userIdentity if one exists
	 * 
	 * @param userId
	 */
	public void removeToken(UserIdentity userId){
		if(!UserIdentity.isValid(userId)){
			LOGGER.debug("Invalid userId.");
			return;
		}
		Long id = userId.getUserId();
		if(getJdbcTemplate().update(SQL_REMOVE_TOKEN,new Object[]{id},SQL_REMOVE_TOKEN_SQL_TYPES) < 1){
			LOGGER.debug("No tokens removed for userId: "+id);
		}else{
			LOGGER.debug("Token removed for userId: "+id);
		}
	}
	
	/**
	 * Note: this will not populate the UserIdentity, only userId will be set
	 * 
	 * @param nonce
	 * @return owner of the given nonce, or null if no such nonce exists or the nonce has expired
	 */
	public UserIdentity getUser(String nonce){
		Long userId = (Long) getJdbcTemplate().queryForMap(SQL_SELECT_USER_ID, new Object[]{nonce,System.currentTimeMillis()}, SQL_SELECT_USER_ID_SQL_TYPES).get(COLUMN_USER_ID);
		return (userId == null ? null : new UserIdentity(userId));
	}
	
	/**
	 * 
	 * @param userId
	 * @return true if record exists for the given user
	 */
	private boolean recordExists(Long userId){
		return (getJdbcTemplate().queryForObject(SQL_COUNT_USER_ID, new Object[]{userId}, SQL_COUNT_USER_ID_SQL_TYPES, Long.class) > 0);
	}
}
