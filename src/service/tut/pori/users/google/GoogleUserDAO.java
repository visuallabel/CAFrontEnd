/**
 * Copyright 2014 Tampere University of Technology, Pori Unit
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package service.tut.pori.users.google;

import java.util.Date;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;

import service.tut.pori.users.OAuth2Token;
import service.tut.pori.users.UserDAO;
import core.tut.pori.dao.clause.SQLClause.SQLType;
import core.tut.pori.dao.SQLDAO;
import core.tut.pori.users.ExternalAccountConnection;
import core.tut.pori.users.UserIdentity;
import core.tut.pori.users.ExternalAccountConnection.UserServiceType;
import core.tut.pori.utils.NonceUtils;
import core.tut.pori.utils.NonceUtils.Nonce;


/**
 * DAO for handling authorization tokens for Google User Service.
 */
public class GoogleUserDAO extends SQLDAO{
	private static final Logger LOGGER = Logger.getLogger(GoogleUserDAO.class);
	/* tables */
	private static final String TABLE_USERS_GOOGLE = DATABASE+".users_google";
	/* columns */
	private static final String COLUMN_ACCESS_TOKEN = "access_token";
	private static final String COLUMN_ACCESS_TOKEN_EXPIRES = "access_token_expires";
	private static final String COLUMN_NONCE = "nonce";
	private static final String COLUMN_NONCE_EXPIRES = "nonce_expires";
	private static final String COLUMN_REFRESH_TOKEN = "refresh_token";
	private static final String COLUMN_TOKEN_TYPE = "token_type";
	/* sql scripts */
	private static final String SQL_COUNT_USER_ID = "SELECT "+COLUMN_COUNT+" FROM "+TABLE_USERS_GOOGLE+" WHERE "+COLUMN_USER_ID+"=?";
	private static final int[] SQL_COUNT_USER_ID_SQL_TYPES = new int[]{SQLType.LONG.toInt()};
	
	private static final String SQL_INSERT_NONCE = "INSERT INTO "+TABLE_USERS_GOOGLE+" ("+COLUMN_USER_ID+","+COLUMN_NONCE+","+COLUMN_NONCE_EXPIRES+","+COLUMN_ROW_CREATED+") VALUES (?,?,?,NOW())";
	private static final int[] SQL_INSERT_NONCE_SQL_TYPES = new int[]{SQLType.LONG.toInt(),SQLType.STRING.toInt(),SQLType.LONG.toInt()};
	
	private static final String SQL_REMOVE_NONCE = "UPDATE "+TABLE_USERS_GOOGLE+" SET "+COLUMN_NONCE+"=NULL WHERE "+COLUMN_NONCE+"=? LIMIT 1";
	private static final int[] SQL_REMOVE_NONCE_SQL_TYPES = new int[]{SQLType.STRING.toInt()};
	
	private static final String SQL_REMOVE_TOKEN = "DELETE FROM "+TABLE_USERS_GOOGLE+" WHERE "+COLUMN_USER_ID+"=?";
	private static final int[] SQL_REMOVE_TOKEN_SQL_TYPES = new int[]{SQLType.LONG.toInt()};
	
	private static final String SQL_SELECT_USER_ID = "SELECT "+COLUMN_COUNT+", "+COLUMN_USER_ID+" FROM "+TABLE_USERS_GOOGLE+" WHERE "+COLUMN_NONCE+"=? AND "+COLUMN_NONCE_EXPIRES+">? LIMIT 1";
	private static final int[] SQL_SELECT_USER_ID_SQL_TYPES = new int[]{SQLType.STRING.toInt(),SQLType.LONG.toInt()};
	
	private static final String SQL_SELECT_TOKEN = "SELECT "+COLUMN_COUNT+", "+COLUMN_ACCESS_TOKEN+", "+COLUMN_ACCESS_TOKEN_EXPIRES+","+COLUMN_REFRESH_TOKEN+","+COLUMN_TOKEN_TYPE+" FROM "+TABLE_USERS_GOOGLE+" WHERE "+COLUMN_USER_ID+"=? AND ("+COLUMN_ACCESS_TOKEN_EXPIRES+">? OR "+COLUMN_REFRESH_TOKEN+" IS NOT NULL) LIMIT 1";
	private static final int[] SQL_SELECT_TOKEN_SQL_TYPES = new int[]{SQLType.LONG.toInt(),SQLType.LONG.toInt()};	
	
	/** tokens generated by google should be unique, so the unique column constraint on access token should never match on ON DUPLICATE KEY UPDATE for two different users, the match will be solely done on user id */
	private static final String SQL_SET_TOKEN = "INSERT INTO "+TABLE_USERS_GOOGLE+" ("+COLUMN_USER_ID+","+COLUMN_ACCESS_TOKEN+","+COLUMN_ACCESS_TOKEN_EXPIRES+","+COLUMN_REFRESH_TOKEN+","+COLUMN_TOKEN_TYPE+","+COLUMN_ROW_CREATED+") VALUES (?,?,?,?,?,NOW()) ON DUPLICATE KEY UPDATE "+COLUMN_ACCESS_TOKEN+"=VALUES("+COLUMN_ACCESS_TOKEN+"), "+COLUMN_ACCESS_TOKEN_EXPIRES+"=VALUES("+COLUMN_ACCESS_TOKEN_EXPIRES+"), "+COLUMN_REFRESH_TOKEN+"=VALUES("+COLUMN_REFRESH_TOKEN+"), "+COLUMN_TOKEN_TYPE+"=VALUES("+COLUMN_TOKEN_TYPE+")";
	private static final int[] SQL_SET_TOKEN_SQL_TYPES = new int[]{SQLType.LONG.toInt(),SQLType.STRING.toInt(),SQLType.LONG.toInt(),SQLType.STRING.toInt(),SQLType.STRING.toInt()};
	
	private static final String SQL_UPDATE_NONCE = "UPDATE "+TABLE_USERS_GOOGLE+" SET "+COLUMN_NONCE+"=?,"+COLUMN_NONCE_EXPIRES+"=? WHERE "+COLUMN_USER_ID+"=?";
	private static final int[] SQL_UPDATE_NONCE_SQL_TYPES = new int[]{SQLType.STRING.toInt(),SQLType.LONG.toInt(),SQLType.LONG.toInt()};
	
	@Autowired
	private UserDAO _userDAO = null;
	
	/**
	 * 
	 * @param googleUserId
	 * @param token
	 * @param userId
	 * @return true on success
	 */
	public boolean setToken(final String googleUserId, final OAuth2Token token, final UserIdentity userId){
		if(!UserIdentity.isValid(userId) || !token.isValid() || StringUtils.isBlank(googleUserId)){
			LOGGER.debug("Invalid userId or token.");
			return false;
		}

		return getTransactionTemplate().execute(new TransactionCallback<Boolean>() {

			@Override
			public Boolean doInTransaction(TransactionStatus status) {
				JdbcTemplate t = getJdbcTemplate();
				
				String oldGoogleUserId = getGoogleUserId(userId);
				if(oldGoogleUserId == null){
					LOGGER.debug("Creating a new external account connection for user, id: "+userId.getUserId()+", google user id: "+googleUserId);
					_userDAO.insertExternalAccountConnection(new ExternalAccountConnection(googleUserId, UserServiceType.GOOGLE), userId);
				}else if(!oldGoogleUserId.equals(googleUserId)){  // do not allow changing the google user, this may cause undefined behavior on other parts of the system
					LOGGER.warn("The given google user Id "+googleUserId+" did not match the old google user id: "+oldGoogleUserId);
					return false;
				}
				
				t.update(SQL_SET_TOKEN, new Object[]{userId.getUserId(),token.getAccessToken(),token.getExpires().getTime(),token.getRefreshToken(),token.getType()}, SQL_SET_TOKEN_SQL_TYPES);
				return true;
			}
		});
	}
	
	/**
	 * 
	 * @param userId non-null, valid userid
	 * @return google user id for the given userId, if known by the system, otherwise returns null
	 */
	public String getGoogleUserId(UserIdentity userId){
		ExternalAccountConnection connection = _userDAO.getExternalAccountConnection(userId, UserServiceType.GOOGLE);
		return (connection == null ? null : connection.getExternalId());
	}
	
	/**
	 * Removes the given nonce if such exists
	 * 
	 * @param nonce
	 */
	public void removeNonce(String nonce){
		if(getJdbcTemplate().update(SQL_REMOVE_NONCE, new Object[]{nonce}, SQL_REMOVE_NONCE_SQL_TYPES) < 1){
			LOGGER.debug("No nonce was cleared.");
		}else{
			LOGGER.debug("Nonce cleared.");
		}
	}
	
	/**
	 * 
	 * @param userId
	 * @return token for the given user or null if none available
	 */
	public OAuth2Token getToken(UserIdentity userId){
		if(!UserIdentity.isValid(userId)){
			LOGGER.debug("Invalid userId.");
			return null;
		}
	
		OAuth2Token token = new OAuth2Token();
		Map<String, Object> row = getJdbcTemplate().queryForMap(SQL_SELECT_TOKEN, new Object[]{userId.getUserId(), System.currentTimeMillis()}, SQL_SELECT_TOKEN_SQL_TYPES);
		for(Entry<String,Object> entry : row.entrySet()){
			String column = entry.getKey();
			switch(column){
				case COLUMN_ACCESS_TOKEN:
					token.setAccessToken((String) entry.getValue());
					break;
				case COLUMN_ACCESS_TOKEN_EXPIRES:
					token.setExpires(new Date((Long) entry.getValue()));
					break;
				case COLUMN_REFRESH_TOKEN:
					token.setRefreshToken((String) entry.getValue());
					break;
				case COLUMN_TOKEN_TYPE:
					token.setType((String) entry.getValue());
					break;
				default:
					if(checkCountColumn(column, entry.getValue()) < 1){	// if we have only one column, check what it is (should be count)
						LOGGER.debug("Unknown column name, or no results.");
						return null;
					}
					break;
			}
		}
		return token;
	}
	
	/**
	 * This generates a new nonce from the given UserId, replacing the old one if one was present
	 * 
	 * @param userId
	 * @return new nonce generated for the given userId
	 */
	public String generateNonce(UserIdentity userId){
		if(!UserIdentity.isValid(userId)){
			LOGGER.debug("Invalid userId.");
			return null;
		}
		Nonce nonce = NonceUtils.generateNonce();	// in theory, it is extremely unlikely that the generated nonce will collide with previously generated one, but...
		if(recordExists(userId.getUserId())){ // ...just in case do not use INSERT ... ON DUPLICATE KEY UPDATE for updating the nonce (as nonce itself is an unique column)
			getJdbcTemplate().update(SQL_UPDATE_NONCE, new Object[]{nonce.getNonce(),nonce.getExpires(),userId.getUserId()}, SQL_UPDATE_NONCE_SQL_TYPES);	// this throw an exception on duplicate nonce if one ever occurs
		}else{
			getJdbcTemplate().update(SQL_INSERT_NONCE, new Object[]{userId.getUserId(),nonce.getNonce(),nonce.getExpires()}, SQL_INSERT_NONCE_SQL_TYPES);	// this throw an exception on duplicate nonce if one ever occurs
		}
		return nonce.getNonce();
	}
	
	/**
	 * remove token from the given userIdentity if one exists
	 * 
	 * @param userId
	 */
	public void removeToken(UserIdentity userId){
		if(!UserIdentity.isValid(userId)){
			LOGGER.debug("Invalid userId.");
			return;
		}
		Long id = userId.getUserId();
		if(getJdbcTemplate().update(SQL_REMOVE_TOKEN,new Object[]{id},SQL_REMOVE_TOKEN_SQL_TYPES) < 1){
			LOGGER.debug("No tokens removed for userId: "+id);
		}else{
			LOGGER.debug("Token removed for userId: "+id);
		}
	}
	
	/**
	 * 
	 * @param nonce
	 * @return owner of the given nonce, or null if no such nonce exists or the nonce has expired
	 */
	public UserIdentity getUser(String nonce){
		Long userId = (Long) getJdbcTemplate().queryForMap(SQL_SELECT_USER_ID, new Object[]{nonce,System.currentTimeMillis()}, SQL_SELECT_USER_ID_SQL_TYPES).get(COLUMN_USER_ID);
		return (userId == null ? null : new UserIdentity(userId));
	}
	
	/**
	 * 
	 * @param userId
	 * @return true if a record exists for the given user id
	 */
	private boolean recordExists(Long userId){
		return (getJdbcTemplate().queryForObject(SQL_COUNT_USER_ID, new Object[]{userId}, SQL_COUNT_USER_ID_SQL_TYPES, Long.class) > 0);
	}
}
