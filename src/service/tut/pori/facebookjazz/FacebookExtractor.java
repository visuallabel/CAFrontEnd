/**
 * Copyright 2014 Tampere University of Technology, Pori Department
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package service.tut.pori.facebookjazz;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;

import service.tut.pori.contentanalysis.Definitions;
import service.tut.pori.contentanalysis.Photo;
import service.tut.pori.contentanalysis.PhotoDAO;
import service.tut.pori.contentanalysis.PhotoList;
import service.tut.pori.contentanalysis.MediaObject;
import service.tut.pori.contentanalysis.MediaObjectList;
import service.tut.pori.contentstorage.FacebookDAO;
import service.tut.pori.contentstorage.FacebookPhotoStorage;
import service.tut.pori.contentstorage.FacebookPhotoStorage.FacebookEntry;
import service.tut.pori.facebookjazz.WeightModifier.WeightModifierType;
import service.tut.pori.users.google.OAuth2Token;
import service.tut.pori.users.facebook.FacebookUserDAO;

import com.restfb.Connection;
import com.restfb.DefaultFacebookClient;
import com.restfb.Facebook;
import com.restfb.Parameter;
import com.restfb.Version;
import com.restfb.types.CategorizedFacebookType;
import com.restfb.types.Comment;
import com.restfb.types.Event;
import com.restfb.types.Group;
import com.restfb.types.StatusMessage;
import com.restfb.types.User;
import com.restfb.types.Video;

import core.tut.pori.context.ServiceInitializer;
import core.tut.pori.http.parameters.DataGroups;
import core.tut.pori.users.UserIdentity;


/**
 * A high-level client implementation for retrieving user's Facebook profile contents.
 */
public final class FacebookExtractor {
	/** default maximum item limit for the extractor */
	public static final int DEFAULT_LIMIT = 200;
	private static final Logger LOGGER = Logger.getLogger(FacebookExtractor.class);

	/* objects */
	private static final String OBJECT_USER_DETAIL= "me";

	/* connections */
	private static final String CONNECTION_COMMENTS = "comments";
	private static final String CONNECTION_EVENTS = "events";
	private static final String CONNECTION_GROUPS = "groups";
	private static final String CONNECTION_LIKES = "likes";
	private static final String CONNECTION_PHOTOS = "photos";
	private static final String CONNECTION_STATUSES = "statuses";
	private static final String CONNECTION_USER_EVENTS = OBJECT_USER_DETAIL+"/"+CONNECTION_EVENTS;
	private static final String CONNECTION_USER_GROUPS = OBJECT_USER_DETAIL+"/"+CONNECTION_GROUPS;
	private static final String CONNECTION_USER_LIKES = OBJECT_USER_DETAIL+"/"+CONNECTION_LIKES;
	private static final String CONNECTION_USER_PHOTOS = OBJECT_USER_DETAIL+"/"+CONNECTION_PHOTOS+"/uploaded";
	private static final String CONNECTION_USER_STATUSES = OBJECT_USER_DETAIL+"/"+CONNECTION_STATUSES;

	/* parameters */
	private static final String PARAMETER_LIMIT = "limit";

	/* FQL QUERIES */
	private static final String FQL_SELECT_USER_DETAILS = "SELECT uid, name FROM user WHERE uid=me()";
	private static final String FQL_SELECT_VIDEO_DETAILS = "SELECT owner, title, description, updated_time, created_time, vid FROM video WHERE owner=me()";
	
	private DefaultFacebookClient _client = null;
	private UserIdentity _userId = null;	
	private WeightModifierList _userTagWeights = null;
	private WeightModifierList _defaultTagWeights = null;

	/**
	 * 
	 * Valid content types for a profile
	 * 
	 */
	public enum ContentType{
		/** Facebook events */
		EVENTS,
		/** Include tags generated by other back-ends. Can only be used in combination with PHOTO_DESCRIPTION */
		GENERATED_TAGS,
		/** Facebook groups */
		GROUPS,
		/** Facebook likes */
		LIKES,
		/** Descriptions generated from Facebook photos/status messages */
		PHOTO_DESCRIPTIONS,
		/** Facebook status messages */
		STATUS_MESSAGES,
		/** Descriptions generated from Facebook videos/status messages */
		VIDEO_DESCRIPTIONS;

		/**
		 * 
		 * @param values
		 * @return values converted to content types
		 * @throws IllegalArgumentException
		 */
		public static EnumSet<ContentType> fromString(List<String> values) throws IllegalArgumentException {
			EnumSet<ContentType> contentTypes = null;
			if(values != null && !values.isEmpty()){
				contentTypes = EnumSet.noneOf(ContentType.class);
				for(String value : values){
					ContentType found = null;
					for(ContentType t : values()){
						if(t.name().equalsIgnoreCase(value)){
							found = t;
							break;
						}
					} // for types
					if(found == null){
						throw new IllegalArgumentException("Bad ContentType: "+value);
					}
					contentTypes.add(found);
				} // for values
			}
			return contentTypes;
		}
	} // enum ContentType

	/**
	 * 
	 * @param userId
	 * @return the extractor or null on failure
	 */
	public static FacebookExtractor getExtractor(UserIdentity userId){
		FacebookExtractor extractor = null;
		OAuth2Token token = ServiceInitializer.getDAOHandler().getSQLDAO(FacebookUserDAO.class).getToken(userId);
		if(token == null){
			LOGGER.debug("No token.");
			return null;
		}
		extractor = new FacebookExtractor(userId);
		extractor._client = new DefaultFacebookClient(token.getAccessToken(), Version.UNVERSIONED);
		return extractor;
	}

	/**
	 * 
	 * @param userId
	 * 
	 */
	private FacebookExtractor(UserIdentity userId){
		_userId = userId;
	}

	/**
	 * 
	 * @return user status messages, if any
	 * 
	 */
	public List<FacebookStatusMessage> getStatusMessages(){
		Connection<StatusMessage> statusConnection = _client.fetchConnection(CONNECTION_USER_STATUSES, StatusMessage.class, Parameter.with(PARAMETER_LIMIT, DEFAULT_LIMIT));
		//also possible to use a timeframe: Parameter.with("since", new Date(1)),Parameter.with("until", new Date())
		List<StatusMessage> messages = statusConnection.getData();
		if(messages.isEmpty()){ // nothing received
			return null;
		}

		List<FacebookStatusMessage> retval = new ArrayList<>();//restfb's lists do not support addAll
		retval.addAll(FacebookStatusMessage.getFacebookStatusMessages(messages));

		int received = messages.size();  // compare against the default limit to see if there are more messages
		while(received == DEFAULT_LIMIT){   // connection.hasNext(), just like the FB's JSON next links cannot be trusted
			statusConnection = _client.fetchConnectionPage(statusConnection.getNextPageUrl(), StatusMessage.class);
			messages = statusConnection.getData();
			received = messages.size();
			if(received > 0){
				retval.addAll(FacebookStatusMessage.getFacebookStatusMessages(messages));
			}    
		}

		if(retval.isEmpty()){
			return null;
		}else{
			Integer messageWeight = getWeight(WeightModifierType.STATUS_MESSAGE__MESSAGE);
			Integer commentWeight = getWeight(WeightModifierType.STATUS_MESSAGE__COMMENT_MESSAGE);
			if(messageWeight == null && commentWeight == null){
				LOGGER.warn("No "+WeightModifierType.STATUS_MESSAGE__MESSAGE.name()+" or "+WeightModifierType.STATUS_MESSAGE__COMMENT_MESSAGE.name());
				return retval;
			}
			for(FacebookStatusMessage message : retval){
				message.setMessageWeight(messageWeight);
				setCommentWeights(commentWeight, message.getMessageComments());
			}
			return retval;
		}
	}
	
	/**
	 * helper method for setting the comment weights
	 * @param list 
	 * @param commentWeight 
	 */
	private void setCommentWeights(Integer commentWeight, List<FacebookComment> list){
		if(list != null && !list.isEmpty()){
			for(FacebookComment c : list){
				c.setMessageWeight(commentWeight);
			}
		}
	}
	
	/**
	 * 
	 * @param type
	 * @return weight value for the type
	 */
	private Integer getWeight(WeightModifierType type){
		if(_userTagWeights == null){
			_userTagWeights = ServiceInitializer.getDAOHandler().getSQLDAO(FacebookJazzDAO.class).getWeightModifiers(_userId);
			if(_userTagWeights == null){
				LOGGER.debug("No user tag weights available.");
				_userTagWeights = new WeightModifierList();
			}
		}
		
		Integer value = _userTagWeights.getModifier(type);
		if(value == null){
			if(_defaultTagWeights == null){
				_defaultTagWeights = ServiceInitializer.getDAOHandler().getSQLDAO(FacebookJazzDAO.class).getWeightModifiers(null);
			}
			if(_defaultTagWeights == null){
				LOGGER.debug("No default tag weights available.");
				_defaultTagWeights = new WeightModifierList();
				return null;
			}
			value = _defaultTagWeights.getModifier(type);
		}
		return value;
	}

	/**
	 * Note: this will only retrieve first {@value service.tut.pori.facebookjazz.FacebookExtractor#DEFAULT_LIMIT} videos
	 * 
	 * @return descriptions or null if none found
	 */
	public List<FacebookVideoDescription> getVideoDescriptions(){
		List<ExtractedVideo> videos = _client.executeFqlQuery(FQL_SELECT_VIDEO_DETAILS, ExtractedVideo.class, Parameter.with(PARAMETER_LIMIT, DEFAULT_LIMIT));

		if(videos.isEmpty()){
			return null;
		}

		List<User> users = _client.executeFqlQuery(FQL_SELECT_USER_DETAILS, User.class);
		String userName = null;
		if(!users.isEmpty()){
			userName = users.get(0).getName();
		}

		StringBuilder likeBuilder = new StringBuilder("SELECT object_id FROM like WHERE object_id IN(");
		List<FacebookVideoDescription> retval = new ArrayList<>();
		for(Iterator<ExtractedVideo> iter = videos.iterator();iter.hasNext();){
			FacebookVideoDescription desc = new FacebookVideoDescription(iter.next());
			likeBuilder.append('\'');
			likeBuilder.append(desc.getId());   // construct fql for like count retrieval
			likeBuilder.append("',");
			if(desc.isValid()){
				desc.setFromName(userName);
				retval.add(desc);
			}
		}

		if(retval.isEmpty()){
			return null;
		}else{
			Integer descriptionWeight = getWeight(WeightModifierType.VIDEO_DESCRIPTION__DESCRIPTION);
			if(descriptionWeight == null){
				LOGGER.warn("No "+WeightModifierType.VIDEO_DESCRIPTION__DESCRIPTION.name());
			}
			
			likeBuilder.setCharAt(likeBuilder.length()-1, ')');
			List<ObjectId> counts = new ArrayList<>(_client.executeFqlQuery(likeBuilder.toString(), ObjectId.class)); // create new to allow modifications to the list
			for(Iterator<FacebookVideoDescription> vdIter = retval.iterator();vdIter.hasNext();){
				FacebookVideoDescription d = vdIter.next();
				d.setDescriptionWeight(descriptionWeight); // set weight
				retrieveComments(d); // retrieve comments
				String objectId = d.getId();
				long count = 0;
				// go through the count list, make sure every description gets a like count value
				for(Iterator<ObjectId> vIter = counts.iterator();vIter.hasNext();){
					ObjectId c = vIter.next();
					if(c.getObjectId().equals(objectId)){
						++count;
						vIter.remove();
					}
				}
				d.setLikeCount(count);
			}  // for descriptions
			
			return retval;
		}
	}

	/**
	 * 
	 * @param desc the list of comments will be set to the desc if any are found
	 */
	private void retrieveComments(FacebookVideoDescription desc){
		String objectId = desc.getId();
		if(StringUtils.isBlank(objectId)){
			LOGGER.warn("Could not retrieve comments, objectId was missing.");
			return;
		}
		Connection<Comment> commentConnection = _client.fetchConnection(objectId+'/'+CONNECTION_COMMENTS, Comment.class, Parameter.with(PARAMETER_LIMIT, DEFAULT_LIMIT));
		//also possible to use a timeframe: Parameter.with("since", new Date(1)),Parameter.with("until", new Date())
		List<Comment> comments = commentConnection.getData();
		if(comments.isEmpty()){ // nothing received
			LOGGER.debug("No comments for video: "+objectId);
			return;
		}
		List<FacebookComment> retval = new ArrayList<>();//restfb's lists do not support addAll
		retval.addAll(FacebookComment.getCommentList(comments));

		int received = comments.size();  // compare against the default limit to see if there are more messages
		while(received == DEFAULT_LIMIT){   // connection.hasNext(), just like the FB's JSON next links cannot be trusted
			commentConnection = _client.fetchConnectionPage(commentConnection.getNextPageUrl(), Comment.class);
			comments = commentConnection.getData();
			received = comments.size();
			if(received > 0){
				retval.addAll(FacebookComment.getCommentList(comments));
			}    
		}
		desc.setDescriptionComments(retval);
		
		Integer commentWeight = getWeight(WeightModifierType.VIDEO_DESCRIPTION__COMMENT_MESSAGE);
		if(commentWeight == null){
			LOGGER.warn("No "+WeightModifierType.VIDEO_DESCRIPTION__COMMENT_MESSAGE.name());
		}else{
			setCommentWeights(commentWeight, retval); // set comment weights
		}
	}

	/**
	 * 
	 * @return likes or null if none found
	 */
	public List<FacebookLike> getLikes(){
		Connection<CategorizedFacebookType> likeConnection = _client.fetchConnection(CONNECTION_USER_LIKES, CategorizedFacebookType.class, Parameter.with(PARAMETER_LIMIT, DEFAULT_LIMIT));

		List<CategorizedFacebookType> likes = likeConnection.getData();
		if(likes.isEmpty()){ // nothing received
			return null;
		}

		List<FacebookLike> retval = new ArrayList<>();//restfb's lists do not support addAll
		retval.addAll(FacebookLike.getFacebookLikes(likes));

		int received = likes.size();  // compare against the default limit to see if there are more messages
		while(received == DEFAULT_LIMIT){   // connection.hasNext(), just like the FB's JSON next links cannot be trusted
			likeConnection = _client.fetchConnectionPage(likeConnection.getNextPageUrl(), CategorizedFacebookType.class);
			likes = likeConnection.getData();
			received = likes.size();
			if(received > 0){
				retval.addAll(FacebookLike.getFacebookLikes(likes));
			}    
		}

		if(retval.isEmpty()){
			return null;
		}else{
			return retval;
		}
	}

	/**
	 * 
	 * @return groups or null if none found
	 */
	public List<FacebookGroup> getGroups(){
		Connection<Group> groupConnection = _client.fetchConnection(CONNECTION_USER_GROUPS, Group.class, Parameter.with(PARAMETER_LIMIT, DEFAULT_LIMIT));

		List<Group> groups = groupConnection.getData();
		if(groups.isEmpty()){ // nothing received
			return null;
		}

		List<FacebookGroup> retval = new ArrayList<>();//restfb's lists do not support addAll
		retval.addAll(FacebookGroup.getFacebookGroups(groups));

		int received = groups.size();  // compare against the default limit to see if there are more messages
		while(received == DEFAULT_LIMIT){   // connection.hasNext(), just like the FB's JSON next links cannot be trusted
			groupConnection = _client.fetchConnectionPage(groupConnection.getNextPageUrl(), Group.class);
			groups = groupConnection.getData();
			received = groups.size();
			if(received > 0){
				retval.addAll(FacebookGroup.getFacebookGroups(groups));
			}    
		}
		
		if(retval.isEmpty()){
			return null;
		}else{
			Integer nameWeight = getWeight(WeightModifierType.GROUP__NAME);
			Integer descriptionWeight = getWeight(WeightModifierType.GROUP__DESCRIPTION);
			if(nameWeight == null && descriptionWeight == null){
				LOGGER.warn("No "+WeightModifierType.GROUP__NAME.name()+" or "+WeightModifierType.GROUP__DESCRIPTION.name());
				return retval;
			}
			
			for(FacebookGroup g : retval){
				g.setDescriptionWeight(descriptionWeight);
				g.setNameWeight(nameWeight);
			}
			
			return retval;
		}
	}

	/**
	 * 
	 * @return events or null if none was found
	 */
	public List<FacebookEvent> getEvents(){
		Connection<Event> eventConnection = _client.fetchConnection(CONNECTION_USER_EVENTS, Event.class, Parameter.with(PARAMETER_LIMIT, DEFAULT_LIMIT));

		List<Event> events = eventConnection.getData();
		if(events.isEmpty()){ // nothing received
			return null;
		}

		List<FacebookEvent> retval = new ArrayList<>();//restfb's lists do not support addAll
		retval.addAll(FacebookEvent.getFacebookEvents(events));

		int received = events.size();  // compare against the default limit to see if there are more messages
		while(received == DEFAULT_LIMIT){   // connection.hasNext(), just like the FB's JSON next links cannot be trusted
			eventConnection = _client.fetchConnectionPage(eventConnection.getNextPageUrl(), Event.class);
			events = eventConnection.getData();
			received = events.size();
			if(received > 0){
				retval.addAll(FacebookEvent.getFacebookEvents(events));
			}
		}

		if(retval.isEmpty()){
			return null;
		}else{
			Integer descriptionWeight = getWeight(WeightModifierType.EVENT__DESCRIPTION);
			Integer nameWeight = getWeight(WeightModifierType.EVENT__NAME);
			if(nameWeight == null && descriptionWeight == null){
				LOGGER.warn("No "+WeightModifierType.EVENT__DESCRIPTION.name()+" or "+WeightModifierType.EVENT__NAME.name());
				return retval;
			}
			
			for(FacebookEvent e : retval){
				e.setDescriptionWeight(descriptionWeight);
				e.setNameWeight(nameWeight);
			}
			
			return retval;
		}
	}
	
	/**
	 * This method will not return generated tags
	 * 
	 * @return list of photo descriptions, ignoring photos without descriptions or comments
	 */
	public List<FacebookPhotoDescription> getPhotoDescriptions(){
		return getPhotoDescriptions(false, false);
	}

	/**
	 * 
	 * @param generatedTags if true the previously generated tags will be retrieved from the database and will be included in the results
	 * @param includeEmpty
	 * @return descriptions or null if none was found
	 */
	public List<FacebookPhotoDescription> getPhotoDescriptions(boolean generatedTags, boolean includeEmpty){
		Connection<com.restfb.types.Photo> photoConnection = _client.fetchConnection(CONNECTION_USER_PHOTOS, com.restfb.types.Photo.class, Parameter.with(PARAMETER_LIMIT, DEFAULT_LIMIT));
		List<com.restfb.types.Photo> photos = photoConnection.getData();
		if(photos.isEmpty()){ // nothing received
			return null;
		}

		List<FacebookPhotoDescription> retval = new ArrayList<>();//for addAll
		for(Iterator<com.restfb.types.Photo> iter = photos.iterator();iter.hasNext();){
			FacebookPhotoDescription photo = new FacebookPhotoDescription(iter.next());
			if(includeEmpty || photo.isValid()){
				retval.add(photo);
			}
		}

		int received = photos.size();  // compare against the default limit to see if there are more messages
		while(received == DEFAULT_LIMIT){   // connection.hasNext(), just like the FB's JSON next links cannot be trusted
			photoConnection = _client.fetchConnectionPage(photoConnection.getNextPageUrl(),com.restfb.types.Photo.class);
			photos = photoConnection.getData();

			for(Iterator<com.restfb.types.Photo> iter = photos.iterator();iter.hasNext();){
				FacebookPhotoDescription photo = new FacebookPhotoDescription(iter.next());
				if(includeEmpty || photo.isValid()){
					retval.add(photo);
				} // if
			} // for
		} // while

		if(retval.isEmpty()){
			return null;
		}else{
			Integer descriptionWeight = getWeight(WeightModifierType.PHOTO_DESCRIPTION__DESCRIPTION);
			Integer commentWeight = getWeight(WeightModifierType.PHOTO_DESCRIPTION__COMMENT_MESSAGE);
			if(commentWeight == null && descriptionWeight == null){
				LOGGER.warn("No "+WeightModifierType.PHOTO_DESCRIPTION__DESCRIPTION.name()+" or "+WeightModifierType.PHOTO_DESCRIPTION__COMMENT_MESSAGE.name());
				return retval;
			}
			
			List<String> objectIds = new ArrayList<>(retval.size());
			for(FacebookPhotoDescription d : retval){
				d.setDescriptionWeight(descriptionWeight);
				setCommentWeights(commentWeight, d.getDescriptionComments());
				objectIds.add(d.getId());
			}
			
			List<FacebookEntry> entries = ServiceInitializer.getDAOHandler().getSQLDAO(FacebookDAO.class).getEntries(objectIds, _userId);
			if(entries == null){
				LOGGER.debug("None of the photos are known by the system.");
			}else{
				PhotoList gTags = null;
				if(generatedTags){
					LOGGER.debug("Retrieving generated tags.");
					List<String> guids = new ArrayList<>(entries.size());
					for(FacebookEntry e : entries){
						guids.add(e.getGUID());
					}
					gTags = ServiceInitializer.getDAOHandler().getSolrDAO(PhotoDAO.class).getPhotos(new DataGroups(Definitions.DATA_GROUP_KEYWORDS), guids, null, null, null);
				}
				
				LOGGER.debug("Resolving photo GUIDs for descriptions.");
				for(FacebookPhotoDescription d : retval){
					String objectId = d.getId();
					for(Iterator<FacebookEntry> eIter = entries.iterator(); eIter.hasNext();){
						FacebookEntry e = eIter.next();
						if(e.getObjectId().equals(objectId)){ // if the new description was found in the list of already known entries
							String guid = e.getGUID();
							d.setPhotoGUID(guid);
							d.setServiceType(FacebookPhotoStorage.SERVICE_TYPE); // no need to check from database, all photos from TwitterDAO entries are of the same type
							if(gTags != null){  // if tags were found
								Photo p = gTags.getPhoto(guid); // in practice this should always return a photo...
								if(p != null){
									MediaObjectList objects = p.getMediaObjects();
									if(!MediaObjectList.isEmpty(objects)){
										for(MediaObject vo : objects.getMediaObjects()){
											d.addTag(FacebookPhotoTag.getFacebookTag(vo));
										} // for
									} // if photo had media objects
								}else{ // ..though there is theoretical possibility that the photo has been removed in between retrievals (which are not in a transaction), and were not found anymore
									LOGGER.warn("No photo found, GUID: "+guid);
									d.setPhotoGUID(null); // not valid anymore
								} // else
							} // if
							eIter.remove();
							break;
						} // if
					} // for entries
				} // for descriptions
			}
			
			return retval;
		}
	}

	/**
	 * @return the userId
	 */
	public UserIdentity getUserId() {
		return _userId;
	}

	/**
	 * 
	 * @param contentTypes list of content types, by default only the basic user details are returned
	 * @return the extracted profile
	 * @throws IllegalArgumentException on incompatible content types
	 */
	public FacebookProfile getProfile(EnumSet<ContentType> contentTypes) throws IllegalArgumentException{
		FacebookUserDetails user = new FacebookUserDetails(_client.fetchObject(OBJECT_USER_DETAIL, User.class));
		user.setUserId(_userId);
		FacebookProfile profile = new FacebookProfile(user);

		if(contentTypes != null && !contentTypes.isEmpty()){
			boolean generatedTags = contentTypes.contains(ContentType.GENERATED_TAGS);
			if(generatedTags && contentTypes.size() == 1){
				throw new IllegalArgumentException("Only "+ContentType.GENERATED_TAGS.name()+" given.");
			}
			
			if(contentTypes.contains(ContentType.STATUS_MESSAGES)){
				profile.setStatusMessages(getStatusMessages());
			}       
			if(contentTypes.contains(ContentType.LIKES)){
				profile.setLikes(getLikes());
			}
			if(contentTypes.contains(ContentType.EVENTS)){
				profile.setEvents(getEvents());
			}
			if(contentTypes.contains(ContentType.GROUPS)){
				profile.setGroups(getGroups());
			}
			if(contentTypes.contains(ContentType.VIDEO_DESCRIPTIONS)){
				profile.setVideoDescriptions(getVideoDescriptions());
			}
			if(contentTypes.contains(ContentType.PHOTO_DESCRIPTIONS)){
				profile.setPhotoDescriptions(getPhotoDescriptions(generatedTags, false));  
			}
		}else{
			LOGGER.debug("No content types requested.");
		}
		return profile;
	}

	/**
	 * 
	 * Helper class for extracting a list of object ids
	 * 
	 */
	private static class ObjectId{
		@Facebook(value = "object_id")
		private String _objectId = null;

		/**
		 * 
		 * @return object id value
		 */
		public String getObjectId(){
			return _objectId;
		}
	}
	
	/**
	 * Extended to contain video id from FQL queries
	 *
	 */
	public static class ExtractedVideo extends Video{
		/** serial version UID */
		private static final long serialVersionUID = 4183565698345218940L;
		@Facebook(value="vid")
		private String _objectId = null;
		
		/**
		 * @return object id (vid) or id if no object id is given
		 */
		@Override
		public String getId() {
			return (StringUtils.isBlank(_objectId) ? super.getId() : _objectId);
		}
		
	} // class ExtractedVideo
}
